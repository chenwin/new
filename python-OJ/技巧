REST API，不同的URL写不同的API，利用动态的__getattr__引入链式调用，一个通用方法搞定。
class Chain(object):
 
    def __init__(self, path=''):
        self._path = path
 
    def __getattr__(self, path):
        return Chain('%s/%s' % (self._path, path))
 
    def __str__(self):
        return self._path
 
    __repr__ = __str__
>>> Chain().status.user.timeline.list
'/status/user/timeline/list'
这样，无论API怎么变，SDK都可以根据URL实现完全动态的调用，而且，不随API的增加而改变！

=====================================================================================
logging
import logging
logging.basicConfig(level=logging.INFO)

这就是logging的好处，它允许你指定记录信息的级别，有debug，info，warning，error等几个级别，当我们指定level=INFO时，logging.debug就不起作用了。
同理，指定level=WARNING后，debug和info就不起作用了。这样一来，你可以放心地输出不同级别的信息，也不用删除，最后统一控制输出哪个级别的信息。
s = '0'
n = int(s)
logging.info('n = %d' % n)
print(10 / n)
======================================================================================
return n if n >= 0 else (-n)

注意：字符串replace函数，返回值是替换后的新str，入参old-str不会变化

字符串函数
s.join(seq)    返回用s把序列seq串联的字符串。
"-".join(["1","2","3"]) 结果为1_2_3


zip为一种创建字典的好方法
m={'a','b','c'}
n={1,2,3}
b=dict(zip(m,n))
print(b)

当文件以文本文件方式打开时,读写按照字符串方式
当文件以二进制文件方式打开时,读写按照字节流方式
======================================================================================
python中eval()与int()的区别

eval(str [,globals [,locals ]])函数将字符串str当成有效Python表达式来求值，并返回计算结果。
1,针对数字，eval()与int() 里面数字的字符串，能否返回相同的结果(9999)。
print eval('9999')   //返回9999
print int('9999')    //返回9999

2,针对字符串的表达式，eval能接受字符串，并把"9999+1"作为表达式求值，而int()调用失败，由于字符串参数不能代表整数的字符串，有非法的文字"+"
print eval('9999+1')   //返回10000
print int('9999+1')    //返回ValueError: invalid literal for int() with base 10: '9999+1'


https://blog.csdn.net/ReCclay/article/details/88375363

